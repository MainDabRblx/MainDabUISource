using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace ProjectMainDab.EasyExploitsInjectionClass
{
	internal class DLLInjection
	{
		public DLLInjection()
		{
		}

		public enum DllInjectionResult
		{
			DllNotFound,
			GameProcessNotFound,
			InjectionFailed,
			Success
		}

		public sealed class DllInjector
		{
			private readonly static IntPtr INTPTR_ZERO;

			private static DLLInjection.DllInjector _instance;

			public static DLLInjection.DllInjector GetInstance
			{
				get
				{
					if (DLLInjection.DllInjector._instance == null)
					{
						DLLInjection.DllInjector._instance = new DLLInjection.DllInjector();
					}
					return DLLInjection.DllInjector._instance;
				}
			}

			static DllInjector()
			{
				DLLInjection.DllInjector.INTPTR_ZERO = (IntPtr)0;
			}

			private DllInjector()
			{
			}

			private bool bInject(uint pToBeInjected, string sDllPath)
			{
				bool flag;
				IntPtr intPtr = DLLInjection.DllInjector.OpenProcess(1082, 1, pToBeInjected);
				if (intPtr != DLLInjection.DllInjector.INTPTR_ZERO)
				{
					IntPtr procAddress = DLLInjection.DllInjector.GetProcAddress(DLLInjection.DllInjector.GetModuleHandle("kernel32.dll"), "LoadLibraryA");
					if (procAddress != DLLInjection.DllInjector.INTPTR_ZERO)
					{
						IntPtr intPtr1 = DLLInjection.DllInjector.VirtualAllocEx(intPtr, (IntPtr)0, (IntPtr)sDllPath.Length, 12288, 64);
						if (intPtr1 != DLLInjection.DllInjector.INTPTR_ZERO)
						{
							byte[] bytes = Encoding.ASCII.GetBytes(sDllPath);
							if (DLLInjection.DllInjector.WriteProcessMemory(intPtr, intPtr1, bytes, (uint)bytes.Length, 0) == 0)
							{
								flag = false;
							}
							else if (DLLInjection.DllInjector.CreateRemoteThread(intPtr, (IntPtr)0, DLLInjection.DllInjector.INTPTR_ZERO, procAddress, intPtr1, 0, (IntPtr)0) != DLLInjection.DllInjector.INTPTR_ZERO)
							{
								DLLInjection.DllInjector.CloseHandle(intPtr);
								flag = true;
							}
							else
							{
								flag = false;
							}
						}
						else
						{
							flag = false;
						}
					}
					else
					{
						flag = false;
					}
				}
				else
				{
					flag = false;
				}
				return flag;
			}

			[DllImport("kernel32.dll", CharSet=CharSet.None, ExactSpelling=false, SetLastError=true)]
			private static extern int CloseHandle(IntPtr hObject);

			[DllImport("kernel32.dll", CharSet=CharSet.None, ExactSpelling=false, SetLastError=true)]
			private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttribute, IntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

			[DllImport("kernel32.dll", CharSet=CharSet.None, ExactSpelling=false, SetLastError=true)]
			private static extern IntPtr GetModuleHandle(string lpModuleName);

			[DllImport("kernel32.dll", CharSet=CharSet.None, ExactSpelling=false, SetLastError=true)]
			private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

			public DLLInjection.DllInjectionResult Inject(string sProcName, string sDllPath)
			{
				DLLInjection.DllInjectionResult dllInjectionResult;
				if (File.Exists(sDllPath))
				{
					uint id = 0;
					Process[] processes = Process.GetProcesses();
					int num = 0;
					while (num < (int)processes.Length)
					{
						if (processes[num].ProcessName != sProcName)
						{
							num++;
						}
						else
						{
							id = (uint)processes[num].Id;
							break;
						}
					}
					if (id != 0)
					{
						dllInjectionResult = (this.bInject(id, sDllPath) ? DLLInjection.DllInjectionResult.Success : DLLInjection.DllInjectionResult.InjectionFailed);
					}
					else
					{
						dllInjectionResult = DLLInjection.DllInjectionResult.GameProcessNotFound;
					}
				}
				else
				{
					dllInjectionResult = DLLInjection.DllInjectionResult.DllNotFound;
				}
				return dllInjectionResult;
			}

			[DllImport("kernel32.dll", CharSet=CharSet.None, ExactSpelling=false, SetLastError=true)]
			private static extern IntPtr OpenProcess(uint dwDesiredAccess, int bInheritHandle, uint dwProcessId);

			[DllImport("kernel32.dll", CharSet=CharSet.None, ExactSpelling=false, SetLastError=true)]
			private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, IntPtr dwSize, uint flAllocationType, uint flProtect);

			[DllImport("kernel32.dll", CharSet=CharSet.None, ExactSpelling=false, SetLastError=true)]
			private static extern int WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] buffer, uint size, int lpNumberOfBytesWritten);
		}
	}
}